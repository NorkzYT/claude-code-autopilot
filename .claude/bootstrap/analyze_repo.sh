#!/usr/bin/env bash
set -euo pipefail

# ─────────────────────────────────────────────────────────────
# analyze_repo.sh — Dynamic repo understanding for OpenClaw agents
#
# Usage:
#   bash analyze_repo.sh <workspace-path> [--deep]
#
# Phase A (default): Static parsing of config files
#   Outputs: .openclaw/TOOLS.md, .openclaw/HEARTBEAT.md, llms.txt
#
# Phase B (--deep): Claude-powered deep codebase scan
#   Outputs: .openclaw/PROJECT.md
# ─────────────────────────────────────────────────────────────

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ─── Helpers ────────────────────────────────────────────────
log()  { printf "\n==> %s\n" "$*"; }
warn() { printf "\n[WARN] %s\n" "$*" >&2; }
skip() { printf "    [SKIP] %s\n" "$*"; }
has()  { command -v "$1" >/dev/null 2>&1; }

AUTO_GEN_MARKER="<!-- AUTO-GENERATED by analyze_repo.sh -->"

# Check if file has custom (non-auto-generated) content
is_custom() {
  local file="$1"
  [[ ! -f "$file" ]] && return 1
  # If file exists but does not have our marker, it's custom
  if ! grep -q "AUTO-GENERATED by analyze_repo.sh" "$file" 2>/dev/null; then
    return 0
  fi
  return 1
}

# ─── Parse Arguments ────────────────────────────────────────
WORKSPACE="${1:-}"
DEEP=false

if [[ -z "$WORKSPACE" ]]; then
  echo "Usage: bash $0 <workspace-path> [--deep]" >&2
  exit 1
fi

shift
while [[ $# -gt 0 ]]; do
  case "$1" in
    --deep) DEEP=true; shift ;;
    *)      warn "Unknown option: $1"; shift ;;
  esac
done

if [[ ! -d "$WORKSPACE" ]]; then
  echo "ERROR: Workspace directory does not exist: $WORKSPACE" >&2
  exit 1
fi

WORKSPACE="$(cd "$WORKSPACE" && pwd)"
OPENCLAW_DIR="$WORKSPACE/.openclaw"
mkdir -p "$OPENCLAW_DIR"

# ─── Extract project name ───────────────────────────────────
PROJECT_NAME=""
PROJECT_DESC=""

# Try package.json
if [[ -f "$WORKSPACE/package.json" ]]; then
  PROJECT_NAME="$(python3 -c "
import json
with open('$WORKSPACE/package.json') as f:
    d = json.load(f)
print(d.get('name', ''))
" 2>/dev/null || echo "")"
  PROJECT_DESC="$(python3 -c "
import json
with open('$WORKSPACE/package.json') as f:
    d = json.load(f)
print(d.get('description', ''))
" 2>/dev/null || echo "")"
fi

# Try pyproject.toml
if [[ -z "$PROJECT_NAME" ]] && [[ -f "$WORKSPACE/pyproject.toml" ]]; then
  PROJECT_NAME="$(python3 -c "
import re
with open('$WORKSPACE/pyproject.toml') as f:
    content = f.read()
m = re.search(r'^name\s*=\s*\"([^\"]+)\"', content, re.MULTILINE)
print(m.group(1) if m else '')
" 2>/dev/null || echo "")"
fi

# Try go.mod
if [[ -z "$PROJECT_NAME" ]] && [[ -f "$WORKSPACE/go.mod" ]]; then
  PROJECT_NAME="$(head -1 "$WORKSPACE/go.mod" 2>/dev/null | awk '{print $2}' | awk -F/ '{print $NF}' || echo "")"
fi

# Try Cargo.toml
if [[ -z "$PROJECT_NAME" ]] && [[ -f "$WORKSPACE/Cargo.toml" ]]; then
  PROJECT_NAME="$(python3 -c "
import re
with open('$WORKSPACE/Cargo.toml') as f:
    content = f.read()
m = re.search(r'^name\s*=\s*\"([^\"]+)\"', content, re.MULTILINE)
print(m.group(1) if m else '')
" 2>/dev/null || echo "")"
fi

# Fallback to directory name
if [[ -z "$PROJECT_NAME" ]]; then
  PROJECT_NAME="$(basename "$WORKSPACE")"
fi

log "Analyzing project: $PROJECT_NAME"

# ═══════════════════════════════════════════════════════════════
# Phase A: Static Parsing
# ═══════════════════════════════════════════════════════════════

if [[ "$DEEP" == "false" ]]; then
  log "Phase A: Static repo analysis..."

  # ─── Detect commands ────────────────────────────────────────
  BUILD_CMD=""
  TEST_CMD=""
  LINT_CMD=""
  DEV_CMD=""
  START_CMD=""
  TYPECHECK_CMD=""
  WORKSPACES=""
  SERVICES=""
  PORTS=""
  ENV_VARS=""
  CI_COMMANDS=""

  # --- package.json ---
  if [[ -f "$WORKSPACE/package.json" ]]; then
    log "  Parsing package.json..."
    eval "$(python3 -c "
import json
with open('$WORKSPACE/package.json') as f:
    d = json.load(f)
scripts = d.get('scripts', {})
ws = d.get('workspaces', [])
if isinstance(ws, dict):
    ws = ws.get('packages', [])

def q(s): return s.replace(\"'\", \"'\\\\''\")

if 'build' in scripts: print(f\"BUILD_CMD='npm run build'\")
if 'test' in scripts: print(f\"TEST_CMD='npm test'\")
if 'lint' in scripts: print(f\"LINT_CMD='npm run lint'\")
if 'dev' in scripts: print(f\"DEV_CMD='npm run dev'\")
if 'start' in scripts: print(f\"START_CMD='npm start'\")
if 'typecheck' in scripts: print(f\"TYPECHECK_CMD='npm run typecheck'\")
elif 'type-check' in scripts: print(f\"TYPECHECK_CMD='npm run type-check'\")
if ws: print(f\"WORKSPACES='{', '.join(ws)}'\")
" 2>/dev/null || echo "")"
  fi

  # --- Makefile ---
  if [[ -f "$WORKSPACE/Makefile" ]]; then
    log "  Parsing Makefile..."
    # Extract phony targets or simple targets
    MAKE_TARGETS="$(grep -E '^[a-zA-Z_-]+:' "$WORKSPACE/Makefile" 2>/dev/null | sed 's/:.*//' | sort -u || echo "")"
    if echo "$MAKE_TARGETS" | grep -q '^build$' && [[ -z "$BUILD_CMD" ]]; then
      BUILD_CMD="make build"
    fi
    if echo "$MAKE_TARGETS" | grep -q '^test$' && [[ -z "$TEST_CMD" ]]; then
      TEST_CMD="make test"
    fi
    if echo "$MAKE_TARGETS" | grep -q '^lint$' && [[ -z "$LINT_CMD" ]]; then
      LINT_CMD="make lint"
    fi
    if echo "$MAKE_TARGETS" | grep -q '^dev$' && [[ -z "$DEV_CMD" ]]; then
      DEV_CMD="make dev"
    fi
    if echo "$MAKE_TARGETS" | grep -q '^typecheck$' && [[ -z "$TYPECHECK_CMD" ]]; then
      TYPECHECK_CMD="make typecheck"
    fi
  fi

  # --- pyproject.toml ---
  if [[ -f "$WORKSPACE/pyproject.toml" ]]; then
    log "  Parsing pyproject.toml..."
    eval "$(python3 -c "
import re
with open('$WORKSPACE/pyproject.toml') as f:
    content = f.read()

# Check for pytest
if '[tool.pytest' in content and not '$TEST_CMD':
    print(\"TEST_CMD='python -m pytest'\")

# Check for ruff or flake8
if '[tool.ruff' in content and not '$LINT_CMD':
    print(\"LINT_CMD='ruff check .'\")
elif '[tool.flake8' in content and not '$LINT_CMD':
    print(\"LINT_CMD='flake8 .'\")

# Check for mypy
if '[tool.mypy' in content and not '$TYPECHECK_CMD':
    print(\"TYPECHECK_CMD='mypy .'\")

# Check build system
m = re.search(r'build-backend\s*=\s*\"([^\"]+)\"', content)
if m and not '$BUILD_CMD':
    backend = m.group(1)
    if 'poetry' in backend:
        print(\"BUILD_CMD='poetry build'\")
    elif 'hatch' in backend:
        print(\"BUILD_CMD='hatch build'\")
    else:
        print(\"BUILD_CMD='python -m build'\")
" 2>/dev/null || echo "")"
  fi

  # --- go.mod ---
  if [[ -f "$WORKSPACE/go.mod" ]] && [[ -z "$BUILD_CMD" ]]; then
    BUILD_CMD="go build ./..."
    [[ -z "$TEST_CMD" ]] && TEST_CMD="go test ./..."
    [[ -z "$LINT_CMD" ]] && LINT_CMD="golangci-lint run"
  fi

  # --- Cargo.toml ---
  if [[ -f "$WORKSPACE/Cargo.toml" ]] && [[ -z "$BUILD_CMD" ]]; then
    BUILD_CMD="cargo build"
    [[ -z "$TEST_CMD" ]] && TEST_CMD="cargo test"
    [[ -z "$LINT_CMD" ]] && LINT_CMD="cargo clippy"
  fi

  # --- docker-compose.yml ---
  for compose_file in "$WORKSPACE/docker-compose.yml" "$WORKSPACE/docker-compose.yaml"; do
    if [[ -f "$compose_file" ]]; then
      log "  Parsing $(basename "$compose_file")..."
      SERVICES="$(python3 -c "
import re
with open('$compose_file') as f:
    content = f.read()
# Simple extraction of service names and ports
in_services = False
current_service = ''
for line in content.split('\n'):
    stripped = line.strip()
    # Top-level services: key
    if re.match(r'^services:', line):
        in_services = True
        continue
    if in_services and re.match(r'^[a-z]', line) and not line.startswith(' '):
        in_services = False
        continue
    if in_services and re.match(r'^  [a-zA-Z_-]+:', line):
        current_service = stripped.rstrip(':')
    if in_services and current_service and '\"' in stripped:
        m = re.search(r'\"(\d+):(\d+)\"', stripped)
        if m:
            print(f'{current_service}|{m.group(1)}')
" 2>/dev/null || echo "")"
      break
    fi
  done

  # --- .env.example ---
  if [[ -f "$WORKSPACE/.env.example" ]]; then
    log "  Parsing .env.example..."
    ENV_VARS="$(grep -E '^[A-Z_]+=' "$WORKSPACE/.env.example" 2>/dev/null | sed 's/=.*//' | head -20 || echo "")"
  fi

  # --- CI workflows ---
  if [[ -d "$WORKSPACE/.github/workflows" ]]; then
    log "  Parsing CI workflows..."
    CI_COMMANDS="$(python3 -c "
import os, re
wf_dir = '$WORKSPACE/.github/workflows'
commands = set()
for fname in os.listdir(wf_dir):
    if not fname.endswith(('.yml', '.yaml')):
        continue
    with open(os.path.join(wf_dir, fname)) as f:
        for line in f:
            line = line.strip()
            if line.startswith('- run:') or line.startswith('run:'):
                cmd = line.split(':', 1)[1].strip()
                if cmd and not cmd.startswith('|'):
                    commands.add(cmd)
for c in sorted(commands):
    print(c)
" 2>/dev/null || echo "")"
  fi

  # --- README.md quick start ---
  README_SECTION=""
  if [[ -f "$WORKSPACE/README.md" ]]; then
    log "  Parsing README.md..."
    README_SECTION="$(python3 -c "
import re
with open('$WORKSPACE/README.md') as f:
    content = f.read()
# Extract Quick Start / Development / Getting Started sections
sections = []
for pattern in [r'##\s+(?:Quick\s+Start|Getting\s+Started|Development)', r'##\s+Setup']:
    m = re.search(pattern, content, re.IGNORECASE)
    if m:
        start = m.start()
        # Find next ## heading
        end_m = re.search(r'\n## ', content[start+5:])
        end = start + 5 + end_m.start() if end_m else min(start + 1000, len(content))
        sections.append(content[start:end].strip())
if sections:
    print('\n\n'.join(sections[:2]))
" 2>/dev/null || echo "")"
  fi

  # ─── Generate TOOLS.md ──────────────────────────────────────
  TOOLS_FILE="$OPENCLAW_DIR/TOOLS.md"

  if is_custom "$TOOLS_FILE"; then
    skip "TOOLS.md has custom content, not overwriting"
  else
    log "  Writing TOOLS.md..."
    {
      echo "$AUTO_GEN_MARKER"
      echo "# TOOLS.md - ${PROJECT_NAME} Commands"
      echo ""
      echo "## Build"
      echo '```'
      echo "${BUILD_CMD:-# No build command detected}"
      echo '```'
      echo ""
      echo "## Test"
      echo '```'
      echo "${TEST_CMD:-# No test command detected}"
      echo '```'
      echo ""
      echo "## Lint"
      echo '```'
      echo "${LINT_CMD:-# No lint command detected}"
      echo '```'
      echo ""
      if [[ -n "$TYPECHECK_CMD" ]]; then
        echo "## Typecheck"
        echo '```'
        echo "$TYPECHECK_CMD"
        echo '```'
        echo ""
      fi
      echo "## Dev Server"
      echo '```'
      echo "${DEV_CMD:-# No dev command detected}"
      echo '```'
      echo ""
      if [[ -n "$WORKSPACES" ]]; then
        echo "## Workspaces"
        echo ""
        echo "$WORKSPACES" | tr ',' '\n' | while read -r ws; do
          ws="$(echo "$ws" | xargs)"
          [[ -n "$ws" ]] && echo "- \`$ws\`"
        done
        echo ""
      fi
      echo "## Service Ports"
      echo ""
      echo "| Service | Port |"
      echo "|---------|------|"
      if [[ -n "$SERVICES" ]]; then
        echo "$SERVICES" | while IFS='|' read -r svc port; do
          [[ -n "$svc" ]] && echo "| $svc | $port |"
        done
      else
        echo "| (none detected) | - |"
      fi
      echo ""
      if [[ -n "$ENV_VARS" ]]; then
        echo "## Environment Variables"
        echo ""
        echo "From \`.env.example\`:"
        echo ""
        echo "$ENV_VARS" | while read -r var; do
          [[ -n "$var" ]] && echo "- \`$var\`"
        done
        echo ""
      fi
      echo "## Git Policy"
      echo ""
      echo "- Feature branches: openclaw/<agent>/<description>"
      echo "- Commit format: conventional commits (feat:, fix:, chore:)"
      echo "- NEVER include Co-Authored-By lines -- commits must appear as the user's own"
      echo "- Create PR when work is complete"
    } > "$TOOLS_FILE"
    log "Created: $TOOLS_FILE"
  fi

  # ─── Generate HEARTBEAT.md ──────────────────────────────────
  HEARTBEAT_FILE="$OPENCLAW_DIR/HEARTBEAT.md"

  if is_custom "$HEARTBEAT_FILE"; then
    skip "HEARTBEAT.md has custom content, not overwriting"
  else
    log "  Writing HEARTBEAT.md..."
    {
      echo "$AUTO_GEN_MARKER"
      echo "# HEARTBEAT.md"
      echo ""
      echo "When asked for a heartbeat, check these and report:"
      echo ""
      if [[ -n "$BUILD_CMD" ]]; then
        echo "1. Build succeeds: \`$BUILD_CMD\`"
      else
        echo "1. Build succeeds: (no build command detected)"
      fi
      if [[ -n "$TEST_CMD" ]]; then
        echo "2. Tests pass: \`$TEST_CMD\`"
      else
        echo "2. Tests pass: (no test command detected)"
      fi
      if [[ -n "$LINT_CMD" ]]; then
        echo "3. Lint clean: \`$LINT_CMD\`"
      else
        echo "3. Lint clean: (no lint command detected)"
      fi
      echo "4. Git status: any uncommitted changes?"
    } > "$HEARTBEAT_FILE"
    log "Created: $HEARTBEAT_FILE"
  fi

  # ─── Generate llms.txt ──────────────────────────────────────
  LLMS_FILE="$WORKSPACE/llms.txt"

  if is_custom "$LLMS_FILE"; then
    skip "llms.txt has custom content, not overwriting"
  else
    log "  Writing llms.txt..."
    {
      echo "# $PROJECT_NAME"
      echo ""
      if [[ -n "$PROJECT_DESC" ]]; then
        echo "> $PROJECT_DESC"
        echo ""
      fi
      echo "## File Structure"
      echo ""
      # List top-level directories
      for item in "$WORKSPACE"/*/; do
        [[ ! -d "$item" ]] && continue
        name="$(basename "$item")"
        # Skip hidden and common non-essential dirs
        case "$name" in
          node_modules|.git|.next|.cache|dist|build|__pycache__|.venv|venv|target|vendor) continue ;;
        esac
        echo "- \`$name/\`"
      done
      echo ""
      echo "## Build & Test"
      echo ""
      [[ -n "$BUILD_CMD" ]] && echo "- Build: \`$BUILD_CMD\`"
      [[ -n "$TEST_CMD" ]] && echo "- Test: \`$TEST_CMD\`"
      [[ -n "$LINT_CMD" ]] && echo "- Lint: \`$LINT_CMD\`"
      [[ -n "$DEV_CMD" ]] && echo "- Dev: \`$DEV_CMD\`"
      echo ""
      echo "## Key Patterns"
      echo ""
      # Detect tech stack
      [[ -f "$WORKSPACE/package.json" ]] && echo "- Node.js / npm"
      [[ -f "$WORKSPACE/tsconfig.json" ]] && echo "- TypeScript"
      [[ -f "$WORKSPACE/pyproject.toml" ]] && echo "- Python"
      [[ -f "$WORKSPACE/go.mod" ]] && echo "- Go"
      [[ -f "$WORKSPACE/Cargo.toml" ]] && echo "- Rust"
      [[ -f "$WORKSPACE/pom.xml" ]] && echo "- Java (Maven)"
      [[ -f "$WORKSPACE/build.gradle" ]] && echo "- Java/Kotlin (Gradle)"
      [[ -f "$WORKSPACE/turbo.json" ]] && echo "- Turborepo monorepo"
      [[ -n "$WORKSPACES" ]] && echo "- Monorepo workspaces: $WORKSPACES"
    } > "$LLMS_FILE"
    log "Created: $LLMS_FILE"
  fi

  log "Phase A complete."
  echo "  Generated files:"
  echo "    - $TOOLS_FILE"
  echo "    - $HEARTBEAT_FILE"
  echo "    - $LLMS_FILE"

# ═══════════════════════════════════════════════════════════════
# Phase B: Deep Scan (Claude-powered)
# ═══════════════════════════════════════════════════════════════

else
  log "Phase B: Deep codebase understanding..."

  PROJECT_FILE="$OPENCLAW_DIR/PROJECT.md"

  if is_custom "$PROJECT_FILE"; then
    skip "PROJECT.md has custom content, not overwriting"
    exit 0
  fi

  if ! has claude; then
    warn "Claude CLI not found — cannot run deep analysis"
    warn "Install Claude Code CLI and re-run: bash $0 $WORKSPACE --deep"
    exit 1
  fi

  log "Running Claude deep scan (this may take a minute)..."

  CLAUDE_PROMPT="You are analyzing the codebase at $WORKSPACE. Read the directory structure, key source files, and configuration. Write a comprehensive PROJECT.md that covers:
1. Project architecture and component map
2. How components interact (data flow, APIs, message passing)
3. Key functions and what they do
4. Directory structure with purpose annotations
5. Tech stack with specific framework patterns
6. Monorepo workspace layout (if applicable)
7. Testing patterns and how to run them
8. Deployment/build pipeline
9. Known gotchas and conventions

Start the file with:
$AUTO_GEN_MARKER
# PROJECT.md - $PROJECT_NAME Architecture

Write ONLY the markdown content, no preamble or explanation."

  CLAUDE_OUTPUT="$(claude --print "$CLAUDE_PROMPT" 2>/dev/null || echo "")"

  if [[ -n "$CLAUDE_OUTPUT" ]]; then
    echo "$CLAUDE_OUTPUT" > "$PROJECT_FILE"
    log "Created: $PROJECT_FILE"
  else
    warn "Claude returned empty output — creating placeholder"
    {
      echo "$AUTO_GEN_MARKER"
      echo "# PROJECT.md - $PROJECT_NAME Architecture"
      echo ""
      echo "<!-- Deep scan failed or returned empty. Re-run: bash analyze_repo.sh $WORKSPACE --deep -->"
      echo ""
      echo "## Overview"
      echo ""
      echo "(Auto-populated by analyze_repo.sh --deep)"
      echo ""
      echo "## Architecture"
      echo ""
      echo "(Auto-populated by analyze_repo.sh --deep)"
    } > "$PROJECT_FILE"
    log "Created placeholder: $PROJECT_FILE"
  fi

  log "Phase B complete."
fi
